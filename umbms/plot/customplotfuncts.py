"""
Spencer Christie
University of Manitoba
July 21, 2021
"""


import numpy as np

import matplotlib.pyplot as plt


# TODO: Redo comments

def plot_with_error(x_data, y_data, y_data_error, label, colours):
    # Function that takes three arrays in x_data, y_data, and error in
    # the y data, and then graphs the data with the error region being
    # transparent. Note however that this function does NOT
    # title the graph or axes, so be sure to do that.
    # Parameters:
    # x_data: array of the x coordinate data.
    # y_data: array of the y coordinate data.
    # y_data_error: array of the error in the y data.
    # label: Label of the graphed line.
    # colour: The colour of the drawn lines

    # Setting the default font to Times New Roman...
    plt.rc('font', family='Times New Roman')

    # Plotting the line:
    plt.plot(x_data, y_data, label=label, color=colours)
    plt.fill_between(x_data, y1=(y_data - y_data_error),
                     y2=(y_data + y_data_error), alpha=0.40, color=colours)
    plt.tick_params(labelsize=20)


def plot_sino_birrs(input_data, title, norm_value, start_time, stop_time,
                    x_label="Antenna Position",
                    y_label="Time of Response (ns)",
                    cbar_label="Magnitude of $\\mathdefault{S_{11}}$ Response",
                    norm=True):
    # This is a function which takes time domain data
    # generated by the BIRRs software at the U of M and displays it as
    # a sinogram.
    # Parameters:
    # input_data: 2D Array of time domain data generated by the BIRRS
    # software. (Must be in floats)
    # title: string title of the generated colormap.
    # norm_value: float/int that sets the maximum value of the
    # of the scale the colorbar uses. Not used if norm is passed as
    # false.
    # start_time/stop_time: floats that are the initial/final time of
    # the scan, in sec. These should be passed the same variables as
    # used in the ICZT.
    # x_label, y_label, and cbar_label: strings for the x, y and
    # colorbar labels of the colormap. These should be kept as their
    # default values.
    # norm: boolean that determines if the max of the colour bar will
    # be set by norm_value.

    # Find the total amount of time points, the total amount of
    # antenna positions, and times at which a scan was taken:
    time_pnt_amount = np.size(input_data, axis=0)
    antnna_position_amount = np.size(input_data, axis=1)
    scan_times = np.linspace(start_time, stop_time, time_pnt_amount)

    # Defining the extent of the plot and its aspect ratio with the
    # variables we got from above:
    plot_extent = [0, antnna_position_amount, scan_times[-1] * 1e9,
                   scan_times[0] * 1e9]
    plot_aspect_ratio = 72 / (scan_times[-1] * 1e9)

    # Generate the figure
    plt.figure()
    plt.rc('font', family='Times New Roman')
    plt.imshow(input_data, cmap='inferno', extent=plot_extent,
               aspect=plot_aspect_ratio)

    # Add some y and x ticks defined by the scan_times and antenna
    # positions:
    plt.tick_params(labelsize=12)
    scan_times *= 1e9
    plt.gca().set_yticks([round(ii, 2)
                          for ii in scan_times[::time_pnt_amount // 8]])
    plt.gca().set_xticks([round(ii)
                          for ii in np.linspace(0, antnna_position_amount,
                                                antnna_position_amount)
                          [::antnna_position_amount // 5]])

    # Make the colorbar and label it:
    cbar = plt.colorbar()
    cbar.ax.tick_params(labelsize=12)
    cbar.set_label(cbar_label, rotation=270, fontsize=15, labelpad=20)

    # Scale has to be set differently depending on if we want it to be
    # normalized:
    if norm:
        plt.clim(0, norm_value)

    else:
        plt.clim(0, np.max(input_data))

    # Label the graph:
    plt.title(title, fontsize=18)
    plt.xlabel(x_label, fontsize=16)
    plt.ylabel(y_label, fontsize=16)

    # Need to return the colorbar instance generated in case we need
    # to do stuff with it later.
    return cbar
