"""
Spencer Christie
University of Manitoba
May 12, 2021
"""


import numpy as np

from umbms import sigproc

# TODO: Redo documentation

def process_data(file_name):
    # This function takes a data file generated by the BIRRS
    # software and organizes it into an array as frequency domain
    # data. Then it returns that array.
    # Parameters:
    # file_name: String. Name of the file to be processed.

    # Get the data with np.genfromtxt:
    raw_array = np.genfromtxt(fname=file_name, dtype=float, delimiter='')

    # Find the number of frequencies and antenna positions
    # from the shape of the array:
    freq_number, antnna_places_x2 = raw_array.shape
    antnna_places = antnna_places_x2 // 2

    # Set up the processed array.
    processed_array = np.zeros(shape=(freq_number, antnna_places),
                               dtype=complex)

    # Now that we now the number of antenna positions and frequencies,
    # iterate over the entire array and convert to complex data type.
    # (BIRRS software only gives the data in floats when it is actually
    # complex.)
    for ii in range(antnna_places):

        processed_array[:, ii] = raw_array[:, 2 * ii] \
                                 + 1j * (raw_array[:, (2 * ii) + 1])

    return processed_array


# TODO: Repair this function - very unoptimized
def truncate_low_freqs(fd_data, ini_f, crop_ini_f, fin_f):
    # Function which takes an array outputted by the process_data
    # function and truncates any frequency below a specified frequency.
    # Parameters:
    # input_array: 2D array. The input array to be truncated.
    # start_freq: Float. The original starting frequency of the scan.
    # new_start_freq: Float. The new starting frequency you want.
    # Must be higher than start_freq, and any frequencies below this
    # will be deleted.
    # stop_freq: Float. The stopping frequency of the data set.

    # Get the number of frequency points, and the number of antenna
    # positions. This assumes the input_array is organized into the
    # BIRRS format, which is why this function only works for an
    # array organized like that.
    n_freqs, n_ant_pos = np.shape(fd_data)
    scan_fs = np.linspace(ini_f, fin_f, n_freqs)
    tar_fs = scan_fs >= crop_ini_f
    cropped_fd = fd_data[tar_fs, :]
    new_ini_f = np.min(scan_fs[tar_fs])

    return cropped_fd, new_ini_f


############################################################
# The following convert_raw function is an essential part of many
# scripts. Make sure to read and understand what it does carefully.
# It relies on all the functions above it and also the ICZT function
# made by Tyson Reimer.
############################################################


def get_cut_td(data_path, c_data_path, i_time, f_time, time_pnts, i_freq,
               f_freq, freq_cut, axis=0, show_cut=False):

    # Process the raw data from the BIRRS software into it's proper
    # form, as complex frequency domain data:
    fd_data = process_data(file_name=data_path)
    cali_fd_data = process_data(file_name=c_data_path)

    # Truncate the frequencies below the freq_cut value:
    fd_data, new_start_freq = truncate_low_freqs(fd_data=fd_data,
                                                 ini_f=i_freq,
                                                 crop_ini_f=freq_cut,
                                                 fin_f=f_freq)
    cali_fd_data, new_start_freq = truncate_low_freqs(fd_data=cali_fd_data,
                                                      ini_f=i_freq,
                                                      crop_ini_f=freq_cut,
                                                      fin_f=f_freq)

    # Convert to the time domain:
    td_data = sigproc.iczt(fd_data=fd_data, ini_t=i_time, fin_t=f_time,
                           n_time_pts=time_pnts, ini_f=new_start_freq,
                           fin_f=f_freq, axis=axis)
    cali_td_data = sigproc.iczt(fd_data=cali_fd_data, ini_t=i_time,
                                fin_t=f_time, n_time_pts=time_pnts,
                                ini_f=new_start_freq, fin_f=f_freq, axis=axis)

    # Calibrate the data:
    td_data_calibrated = np.abs(td_data - cali_td_data)

    if show_cut:

        print("After cutting, new initial frequency is %s" % new_start_freq)
        return td_data_calibrated, new_start_freq

    else:
        return td_data_calibrated


############################################################
# The following 2 functions are related to finding a ROI.
# Better known as a region of interest. They are important in
# when cropping for a triton scan.
############################################################


def get_roi_1d_stats(array, cutoff, roi_array):
    # Function that takes two arrays of data. One which defines a roi
    # (region of interest) and another array which has its array indexes
    # truncated based upon if their indices are inside the roi or not.
    # Then returns the mean, std, and 1D array of the truncated data
    # set.
    # Parameters:
    # array: The array to be truncated. Must be 2D and of same size
    # as roi_array.
    # cut_off: Float between 0 and 1, which determines how small the
    # roi is, the closer it is to 1, the smaller the roi.
    # roi_array: The array which defines the region of interest (roi).

    # The roi is defined as follows:
    # Firstly, take the highest value in roi_array and multiply it by
    # the cutoff value to get the actual cutoff value. Then, find all
    # values in roi_array that are higher than than the actual cutoff
    # value and save their indices. Lastly, take those indices
    # and save all of the values in array that correspond to those
    # indices as a 1D array.

    # First, find the actual cutoff value:
    actual_cutoff = cutoff * np.max(roi_array)

    # Then find all values in the roi_array that are in the roi
    # based on the actual_cutoff value:
    boolean_array = roi_array >= actual_cutoff

    # Now determine the data values in the roi in the array
    # and determine the mean and standard deviation of these data
    # values:
    truncated_data = array[boolean_array]  # Note this is a 1D array
    truncated_mean = np.mean(truncated_data)
    truncated_std = np.std(truncated_data)

    # Tyson code below
    q75, q25 = np.percentile(truncated_data, [75, 25])
    iqr = q75 - q25

    return truncated_data, truncated_mean, iqr


def get_roi_2d(array, roi_array, cutoff):
    # Function that takes two arrays of data. One which defines a roi
    # (region of interest) and another array which has its values
    # set to 0 based upon if they are inside the roi or not. Then
    # returns a copy of array with all values outside the ROI set to 0.
    # Parameters:
    # array: The array to be truncated. Must be 2D and of same size
    # as roi_array.
    # cut_off: Float between 0 and 1, which determines how small the
    # roi is, the closer it is to 1, the smaller the roi.
    # roi_array: The array which defines the region of interest (roi).

    # The roi is defined as follows:
    # Firstly, take the highest value in roi_array and multiply it by
    # the cutoff value to get the actual cutoff value. Then, find all
    # values in roi_array that are higher than than the actual cutoff
    # value and save their indices. Lastly, take those indices
    # and save all of the values in array that correspond to those
    # indices as a 1D array.

    # Finding the actual value that defines the ROI
    roi_value = np.max(roi_array) * cutoff

    # Finding the dimensions of the input array:
    rows, columns = np.shape(array)

    # This next line uses advanced indexing from numpy to create a
    # boolean array that is of the same dimensions as roi_array and
    # array. If an index is 'true' it is in the ROI, otherwise it is
    # not.
    bool_index_array = roi_array > roi_value

    # Now initialize the array that will be returned.
    returned_array = np.zeros(shape=(rows, columns))

    # Now loop over every element in the array and if its in the ROI,
    # copy it to returned_array. If not, set it to 0.
    for ii in range(rows):

        for jj in range(columns):

            # If the index is in the roi...
            if bool_index_array[ii, jj]:

                # Copy the value from the original array.
                returned_array[ii, jj] = array[ii, jj]

                # Otherwise do nothing (it's already 0 by default)

    return returned_array
