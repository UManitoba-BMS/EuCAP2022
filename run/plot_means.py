"""
Spencer Christie
University of Manitoba
July 26th, 2021
"""


import os

from pathlib import Path

import numpy as np
import seaborn as sns

import matplotlib.pyplot as plt
from matplotlib.cm import get_cmap

from umbms import get_proj_path, verify_path, get_script_logger


from umbms.pathing import findpaths as fp
from umbms.plot import customplotfuncts as cpf
from umbms import processdata as procd

# TODO: Redo documentation

###############################################################################

all_sessions = os.listdir(os.path.join(get_proj_path(), 'data/'))

for session_str in all_sessions:


    __DATA_DIR = os.path.join(get_proj_path(), 'data/%s/' % session_str)

    __OUT_DIR = os.path.join(get_proj_path(), 'output/%s/' % session_str)
    verify_path(__OUT_DIR)

    ###############################################################################
    # This is the control panel, with all the important variables that
    # determine how this script operates. These are the only variables
    # that should be changed.

    save = True  # if true, saves figures, else shows them to you.
    # If crop_tri_1 is true, crops the data with respect to Triton 1
    # and 'compares' (does a t-test with the alternative hypothesis of
    # 'greater') the highest mean adipose response to Plastic Shell 1.
    # If False, crops by Triton 2 and compares to Plastic Shell 2.
    crop_tri_1 = True
    ##############################################################

    # Load the names and file paths of the scans, which is done via a
    # "key" which is  really just a plain text document in the data
    # directory that has the names of all the scans in an ordered list.
    scan_names = fp.load_session_md(session_dir=__DATA_DIR)
    scan_paths = fp.load_session_fd(n_expts=len(scan_names), session_dir=__DATA_DIR)

    # Delete the air scan because it is not needed here:
    for ii in range(len(scan_names)):

        if scan_names[ii].startswith("Air"):

            scan_names = np.delete(arr=scan_names, obj=ii)
            scan_paths = np.delete(arr=scan_paths, obj=ii)
        #
        # elif scan_names[ii].startswith("Bad Triton"):
        #     scan_names = np.delete(arr=scan_names, obj=ii)
        #     scan_paths = np.delete(arr=scan_paths, obj=ii)

    # initialize these early to avoid warnings:
    crop_name = None
    crop_scan = None
    excluded = None

    # If we want to crop with Triton 1 as the crop scan, find its
    # info:
    if crop_tri_1:

        for ii in range(len(scan_names)):

            if scan_names[ii].startswith("Triton 1"):

                crop_scan = scan_paths[ii]
                crop_name = scan_names[ii]
                excluded = np.array(["Triton 2", "Plastic Shell 2"])

    # If we don't want to crop with Triton 1, crop with Triton 2 instead:
    else:

        for ii in range(len(scan_names)):

            if scan_names[ii].startswith("Triton 2"):

                crop_scan = scan_paths[ii]
                crop_name = scan_names[ii]
                excluded = np.array(["Triton 1", "Plastic Shell 1"])

    if crop_name is None or crop_scan is None or excluded is None:
        raise Exception("Some needed data files weren't found! Check data folder.")

    print("Cropping by %s" % crop_name)

    # This program charts the average value over a range of cutoff values.
    cutoff_thresholds = np.linspace(0, 1, 100)

    # Named constants for the ICZT transform.
    INITIAL_TIME = 0.5e-9  # In seconds
    FINAL_TIME = 5.5e-9  # In seconds
    NMBR_OF_TIME_PNTS = 700
    INITIAL_FREQ = 1e9  # In hz
    FINAL_FREQ = 8e9  # In hz
    AXIS = 0

    # Any frequencies below this cutoff_freq are removed before we convert
    # to the time domain.
    cutoff_freq = 1.65e9  # In hz

    viridis = get_cmap('viridis')

    # Now that we have all the important variables defined...

    # We need to get the size and shape of the array generated by
    # the BIRRS software. So create a test data array:
    test_array, new_i_freq = procd.get_cut_td(data_path=scan_paths[0],
                                              c_data_path=scan_paths[1],
                                              i_time=INITIAL_TIME, f_time=FINAL_TIME,
                                              time_pnts=NMBR_OF_TIME_PNTS,
                                              i_freq=INITIAL_FREQ, f_freq=FINAL_FREQ,
                                              freq_cut=cutoff_freq, show_cut=True)
    row_amount, column_amount = test_array.shape
    print("Number of rows is %s and number of columns is %s"
          % (row_amount, column_amount))

    # For each scan...
    for ii in range(len(scan_names)):

        # The loop iterates over all scans, but we actually only want to
        # iterate over all reference (adipose) scans. So skip the loop
        # if it is not an adipose scan:
        if not scan_names[ii].startswith("Adipose"):
            continue

        # Get the reference scan:
        ref_scan_path = scan_paths[ii]
        ref_scan_name = scan_names[ii]
        print("%s is currently the reference." % scan_names[ii])

        # Make local numpy lists where the reference scan is deleted.
        # The reference is subtracted from all scans, so it itself cannot
        # be shown whilst being used as a reference.
        new_scan_names = np.delete(arr=scan_names, obj=ii)
        new_scan_paths = np.delete(arr=scan_paths, obj=ii)
        new_scan_data = np.zeros(shape=(len(new_scan_paths), row_amount,
                                        column_amount))

        crop_array = procd.get_cut_td(data_path=crop_scan,
                                      c_data_path=ref_scan_path,
                                      i_time=INITIAL_TIME, f_time=FINAL_TIME,
                                      time_pnts=NMBR_OF_TIME_PNTS,
                                      i_freq=INITIAL_FREQ, f_freq=FINAL_FREQ,
                                      freq_cut=cutoff_freq)

        # For each of the new_scan_paths (AKA all scans but the reference):
        for jj in range(len(new_scan_paths)):

            # Get the data for that scan:
            new_scan_data[jj] = procd.get_cut_td(data_path=new_scan_paths[jj],
                                                 c_data_path=ref_scan_path,
                                                 i_time=INITIAL_TIME,
                                                 f_time=FINAL_TIME,
                                                 time_pnts=NMBR_OF_TIME_PNTS,
                                                 i_freq=INITIAL_FREQ,
                                                 f_freq=FINAL_FREQ,
                                                 freq_cut=cutoff_freq)
            print("%s data was just obtained." % new_scan_names[jj])

        # Now that we have the data...

        # We need to set up a few arrays to store the means/standard
        # deviations of each of the scans.
        data_means = np.zeros(shape=(len(new_scan_paths), len(cutoff_thresholds)))
        data_stds = np.zeros(shape=(len(new_scan_paths), len(cutoff_thresholds)))

        plt.figure(figsize=(12, 8))
        plt.rc('font', family='Times New Roman')

        # For each of the new_scan_paths...
        for jj in range(len(new_scan_paths)):

            # For each of the cutoff_thresholds...
            for kk in range(len(cutoff_thresholds)):

                # Get the means and stds. roi_analysis also gives the
                # data set itself, but we don't need that right now
                # so we pass a dummy_var to it to avoid errors.
                dummy_var, data_means[jj, kk], data_stds[jj, kk] =\
                    procd.get_roi_1d_stats(array=new_scan_data[jj],
                                           cutoff=cutoff_thresholds[kk],
                                           roi_array=crop_array)

                # Tyson code below
                this_data = new_scan_data[jj]
                thresh = 0.5
                cutoff = thresh * np.max(crop_array)
                roi = crop_array >= cutoff
                tar_pix = this_data[roi]

                # sns.distplot(tar_pix)
        # plt.show()





        plt.rcParams['figure.figsize'] = (10, 6)

        # scan_name_order = [
        #     'Triton',
        #     'Plastic',
        #     'Adipose 1',
        #     'Adipose 2',
        #     'Adipose 3'
        # ]
        # scan_cols = [
        #     viridis(0.0),
        #     viridis(0.25),
        #     viridis(0.5),
        #     viridis(0.75),
        #     viridis(0.9)
        #
        # ]

        # For each scan...
        for jj in range(len(new_scan_names)):
        # for jj in range(len(scan_name_order)):
        #     cpf.plot_with_error(x_data=cutoff_thresholds,
        #                         y_data=data_means[jj],
        #                         y_data_error=data_stds[jj],
        #                         label=new_scan_names[jj],
        #                         colours=scan_cols[jj])

            # So long as the scan we're looking at is not an excluded
            # scan, graph it.
            if not (new_scan_names[jj] in excluded):

                if new_scan_names[jj].startswith("Triton"):
                    coloured = viridis(0)

                elif new_scan_names[jj].startswith("Plastic"):
                    coloured = viridis(0.2)

                elif new_scan_names[jj].startswith("Adipose 1"):
                    coloured = viridis(0.4)

                elif new_scan_names[jj].startswith("Adipose 2"):
                    coloured = viridis(0.6)

                elif new_scan_names[jj].startswith("Adipose 3"):
                    coloured = viridis(0.8)

                else:
                    coloured = viridis(0.9)

                cpf.plot_with_error(x_data=cutoff_thresholds,
                                    y_data=data_means[jj],
                                    y_data_error=data_stds[jj],
                                    label=new_scan_names[jj],
                                    colours=coloured)

        y_axes_title = "Mean $\\mathdefault{S_{11}}$ Response"
        plt.xlabel("Threshold Value", fontsize=22)
        plt.xlim(0, 1)
        plt.ylabel(y_axes_title, fontsize=22)
        # plt.title("Means with respect to %s" % ref_scan_name, fontsize=25)
        plt.legend(fontsize=18)

        if save:

            save_file_path = __OUT_DIR + "\\" + "Means_WRT_" + ref_scan_name \
                             + "_cropped_by_" + crop_name + "_IQR.png"
            plt.savefig(fname=save_file_path, dpi=300, transparent=False)
            plt.clf()

        else:
            plt.show()
        plt.close('all')